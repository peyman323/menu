//region Imports
const Debug = require('debug')
//import stackinfo from 'stackinfo'
import isNode from 'is-node'
import chalk from 'chalk'
import {getCallerFile, makeIDELink} from 'live-caller'
import logCallsite from './logCallsite'
//endregion

// Uncomment to track to spurious console.log calls.
//logCallsite.hookConsoleLog()

class Logger {

  ns = '';

  constructor(ns = '') {
    this.ns = ns
    this.logger = Debug(ns)
    //this.logger.log = console.log.apply(console, arguments)
    //this.logger = console.log
  }

  log(...args) {
    //const callInfo = callsite()
    this.logger.apply(this.debugModule, args)
    return this
  }

  debug(...args) {
    const callInfo = getCallerFile()
    this.logger.apply(this.debugModule, args)
    if (callInfo) {
      this.logger.apply(this.debugModule, ['  ' + chalk.gray(makeIDELink(callInfo))])
    }
    return this
  }

  error(...args) {
    console.error(...args)
    return this
  }

  warn(...args) {
    console.warn('WARNING:', ...args)
    return this
  }

}

class Decorators {

  logFn;

}

// Main export.

const makeLogger = (ns) => {
  const logger = new Logger(ns)
  logger.log = logger::logger.log
  logger.debug = logger::logger.debug
  logger.warn = logger::logger.warn
  logger.error = logger::logger.error
  return logger
}

// For convenience without having to instantiate a logger using `new` (e.g. `import log from 'live-log`)
// we create a singleton instance of the logger.

const main = makeLogger

const singleton = new Logger

main.log = singleton::singleton.log
main.debug = singleton::singleton.debug
main.warn = singleton::singleton.warn
main.error = singleton::singleton.error

module.exports = main

// TODO: Maybe don't cache the logger so it creates an instance each time
//  and uses the callsite to get the name of the module.
