'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluginLoader = undefined;

var _locator = require('../locator');

var _locator2 = _interopRequireDefault(_locator);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _string = require('string');

var _string2 = _interopRequireDefault(_string);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _dict = require('core-js/library/fn/dict');

var _dict2 = _interopRequireDefault(_dict);

var _outlet = require('outlet');

var _isNode = require('is-node');

var _isNode2 = _interopRequireDefault(_isNode);

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//region Imports

var _require = require('live-log')('live:plugin-loader');

var debug = _require.debug;

//endregion

var useDynamicRequire = false;

// TODO(vjpr): Add flowtypes.

var PluginLoader = exports.PluginLoader = function () {
  function PluginLoader(container, serviceHub) {
    (0, _classCallCheck3.default)(this, PluginLoader);

    this.container = container;
    this.serviceHub = serviceHub;
    _lodash2.default.defaults(this.container, {
      vent: new _eventemitter2.default(),
      state: {}
    });
  }

  (0, _createClass3.default)(PluginLoader, [{
    key: 'loadPlugins',
    value: function loadPlugins() {
      var _this = this;

      var _getPluginFiles = this.getPluginFiles(this.container);

      var files = _getPluginFiles.files;
      var dynamicRequire = _getPluginFiles.dynamicRequire;

      (0, _lodash2.default)(files).each(function (f) {
        var rawModule = _this.requireModule(f, dynamicRequire);
        _this.register(rawModule, f);
      }).run();

      // TODO: Files are two different things (webpack or node path). Change this.
      return files;
    }
  }, {
    key: 'register',
    value: function register(rawModule) {
      var fullPath = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var _getLiveModule = this.getLiveModule(rawModule);

      var module = _getLiveModule.module;
      var registerFn = _getLiveModule.registerFn;

      // Invalid module.

      if (!module) {
        var text = fullPath ? fullPath : '\n' + rawModule.toString();
        this.container.vent.emit('invalid-module', text);
        return;
      }

      // Set module name, if it doesn't exist.
      if (!module.$name) module.$name = this.getModuleName(fullPath, module);

      module.$fullPath = fullPath;
      if (fullPath) module.$projectRelativePath = _path2.default.relative(process.cwd(), fullPath);

      this.printPlugin(fullPath, module.$name);

      // Extract these out of the plugin loader.

      this.registerLiveModuleConfig({ module: module });

      // TODO(vjpr): Validate json schema.

      this.registerLiveModule({ module: module, registerFn: registerFn });

      this.registerLiveModuleServices({ module: module });
    }

    // TODO(vjpr): Over-engineering. Abstract this away.
    ///
    /// Allows us to support a variety of Live module formats.
    ///
    /// We need to do two things with modules.
    /// - Read meta-data from the module.
    /// - Pass the Live application instance to a registration function.
    ///
    /// @param {} module - the result of a `require(...)` call.
    /// @returns {object} obj
    /// @returns {object} obj.module - the instantiated Live module.
    /// @returns {Function} obj.registerFn - function which is passed the Live application instance.
    ///

  }, {
    key: 'getLiveModule',
    value: function getLiveModule(rawModule) {

      // Plain object.
      if (rawModule.register) return { module: rawModule, registerFn: rawModule.register };

      // Class.
      if (rawModule.prototype) {
        // We don't require register method anymore.
        //if (!rawModule.prototype.register) return {module: null}
        var liveModule = new rawModule();
        return { module: liveModule, registerFn: liveModule.register };
      }

      // Function.
      if (_lodash2.default.isFunction(rawModule)) {
        return { module: rawModule, registerFn: rawModule };
      }

      return { module: null };
    }
  }, {
    key: 'getModuleName',
    value: function getModuleName(fullPath, module) {
      if (module.name) return module.name;
      if (fullPath) {
        //if (!isNode) return null
        return _path2.default.basename(_path2.default.dirname(fullPath)); // TODO: Double check this works for webpack - context.keys()! Maybe we can get more info from the context.)
      } else {
          return null;
        }
    }

    //
    // Register a module.
    //
    // Calls the register method on a module.
    //

  }, {
    key: 'registerLiveModule',
    value: function registerLiveModule(_ref) {
      var module = _ref.module;
      var registerFn = _ref.registerFn;

      var moduleName = module.$name;

      // Create a namespace for each module in our `state` variable in our container.

      this.createContainerStateNamespace(moduleName);

      // Register plugin.

      // TODO(vjpr): Should we depend on Outlet here?
      var live = new _outlet.Outlet(this.container);
      live.moduleName = moduleName;
      registerFn && registerFn.call(module, live);
    }

    // Register services using LiveServiceHub.

  }, {
    key: 'registerLiveModuleServices',
    value: function registerLiveModuleServices(_ref2) {
      var _this2 = this;

      var module = _ref2.module;

      if (!module.services) return;

      // TODO(vjpr): `this` is not working inside named functions. WTF.
      //   Maybe a old buggy babel version.

      var consumers = function consumers(obj) {
        for (var keyPath in obj) {
          var versionToFnName = obj[keyPath];
          for (var version in versionToFnName) {
            var fnName = versionToFnName[version];
            var consumerCallback = module[fnName].bind(module);
            if (!consumerCallback) {
              throw new Error('Consumer callback method \'' + fnName + '\' not found on module \'' + module.$projectRelativePath + '\'');
            }
            // TODO(vjpr): Instrument consumerCallback for logging.
            _this2.serviceHub.consume(keyPath, version, consumerCallback);
          }
        }
      };

      var providers = function providers(obj) {
        for (var keyPath in obj) {
          var versionToFnName = obj[keyPath];
          for (var version in versionToFnName) {
            var fnName = versionToFnName[version];
            var serviceGetter = module[fnName].bind(module);
            if (!serviceGetter) {
              throw new Error('Service getter method \'' + fnName + '\' not found on module \'' + module.$projectRelativePath + '\'');
            }
            console.log('Initializing provider service', keyPath, version);
            var service = serviceGetter();
            _this2.serviceHub.provide(keyPath, version, service);
          }
        }
      };

      if (module.services.consume) consumers(module.services.consume);
      if (module.services.provide) providers(module.services.provide);
    }
  }, {
    key: 'registerLiveModuleConfig',
    value: function registerLiveModuleConfig(_ref3) {
      var module = _ref3.module;

      // When this is run, configurize will have already initialized.

      if (!module.config) return;

      if (__CLIENT__) {
        require('configurize.browser').config.setDefaults(module.$name, module.config);
      } else {
        require('configurize').config.setDefaults(module.$name, module.config);
      }
    }
  }, {
    key: 'createContainerStateNamespace',
    value: function createContainerStateNamespace(moduleName) {
      if (moduleName) {
        var ns = (0, _string2.default)(moduleName).camelize();
        // Multiple modules maybe be registered under one namespace when using `live.shared.js`.
        if (!this.container.state[ns]) this.container.state[ns] = {};
      } else {
        throw new Error('You must provide a name for your plugin. Add a `$name` property to the live file.');
      }
    }
  }, {
    key: 'requireModule',
    value: function requireModule(f) {
      if (__CLIENT__) {
        // Plugins will already be setup on window object.
        debug('Requiring module:', f);
        return window.livePlugins[f];
      } else {
        return require('./node')(f);
      }
    }
  }, {
    key: 'getPluginFiles',
    value: function getPluginFiles() {
      var files = undefined;
      if (__CLIENT__) {
        // NOTE: This file is generated on webpack build.
        //const livePlugins = require('generated/live-browser-plugin-requires-generated')
        var livePlugins = window.livePlugins; // Alternative.
        debug('Found Live Plugins', livePlugins);
        files = (0, _keys2.default)(livePlugins);
      } else {
        files = (0, _locator2.default)();
      }
      return { files: files };
    }
  }, {
    key: 'getRawModules',
    value: function getRawModules(files) {}

    // TODO(vjpr): Add an explanation of how this works. Reading from the top should
    // explain everything. Who calls what and from where.

  }, {
    key: 'printPlugin',
    value: function printPlugin(fullPath, moduleName) {
      var relPath = fullPath ? _path2.default.relative(process.cwd(), fullPath) : '';
      this.container.vent.emit('register-plugin', { moduleName: moduleName, relPath: relPath });
    }
  }]);
  return PluginLoader;
}();
//# sourceMappingURL=index.js.map
